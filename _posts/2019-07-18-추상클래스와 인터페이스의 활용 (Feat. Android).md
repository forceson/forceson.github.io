---
title: 추상클래스와 인터페이스의 활용 (Feat. Android)
last_modified_at: 2019-07-18T23:47:00+09:00
category: Android
tags: [안드로이드, Android, 추상클래스, 인터페이스]
---

추상클래스와 인터페이스는 자바나 코틀린을 공부할 때 항상 튀어나오는 주제이다. 오늘도 코틀린을 공부하는 와중에 추상클래스와 인터페이스가 등장했다. 그래서 이참에 한 번 정리를 해보면 좋을 것 같아서 정리해본다.

들어가기에 앞서 '추상'과 '추상화', '구체화'의 의미를 알고 가자.

추상 - 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용

추상화 - 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업

구체화 - 상속을 통해 클래스를 구현, 확장하는 작업

## 추상클래스와 인터페이스의 차이

### 추상클래스

- 미완성 설계도, 인스턴스화 X
- 상속을 통해서 자손 클래스에 의해서만 완성될 수 있다.
- 자체로는 클래스로서의 역할을 다 못하지만, 새로운 클래스를 작성하는데 있어 바탕이 된다.
- 조상클래스로서 중요한 의미를 갖는다.

### 인터페이스

- 밑그림만 그려져 있는 '기본 설계도', 인스턴스화 X
- 구현 클래스가 필요하다.
- 추상화 정도가 높아서 일반 메서드, 멤버 변수를 가질 수 없다. 추상 메서드와 상수만 가능 ← 사실 틀린말이다. Java 1.8 부터는 인터페이스안에 구현 메서드인 default 메서드도 가질 수 있게 되었다.
- 인터페이스는 인터페이스로부터만 상속 가능. 다중 상속 가능.

### 공통점

모두 미완성이기 때문에 구현해줄 구현클래스가 반드시 필요하다. 자식클래스가 무언가를 반드시 구현해야할 때 사용한다. 원래는 상속에서부터 다루어야하지만, 상속이라는 특징 때문에 두 가지 모두 다형성을 표현할 수 있기 때문에 느슨한 결합이 가능해진다. 느슨한 결합(Loose Coupling)이란 객체끼리 상호작용은 있지만 서로를 잘 모르는 것이다. 느슨한 결합은 유지보수하기 편하고 테스트 가능한 코드를 만들어낸다. 물론 객체 간의 상속을 줄이고 Composition을 이용하여 객체를 전달하며, 의존성 주입을 구현해야 느슨한 결합이 보다 완성될 수 있지만 다형성이 기초적인 역할을 한다. 느슨한 결합에는 팩토리 패턴까지 들어가기도 하던데 이 부분은 나중에 디자인패턴을 더 자세히 공부해서 채워넣어야겠다.

### 차이점

사실 차이점이 중요하다.

문법적인 차이점보다 사용하는 목적이 중요하다고 본다. 키워드는 **확장성과 동일 기능**이다.

추상클래스는 좀 더 확장의 개념을 가지고 있고, 인터페이스는 동일 기능을 하도록 보장하는 개념을 가지고 있다.게임 스타크래프트의 저그 종족을 예로 들면 모든 유닛들은 움직이거나 멈출 수 있으며 일정 시간마다 HP가 채워지는 공통의 작업을 수행할 수 있고, 일부 유닛만이 오버로드라는 유닛에 탈 수 있는 기능을 할 수가 있다. 

그렇다면 최상위 객체인 ZergUnit에는 move(), stop(), recover() 메서드를 만들어 줄 수 있다. 여기서 move()와 recover()는 유닛마다 다를 수 있으므로 abstract를 시켜줘야한다.
```Java
    abstract class ZergUnit {
    		int x, y;
    		abstract void move(int x, int y);
    		void stop() { /* 현재 위치에 정지 */ }
    		abstract void recover(int timeFlag);
    }
```
이렇게 만들고 ZergUnit을 상속받은 Mutalisk은 move(), recover()를 구현해야 하고 공통 기능인 stop()을 이용할 수 있게 된다. 이외에 Mutalisk 고유의 공격기능이나 기타 필요한 기능들을 추가하여 ZergUnit으로부터 확장될 수 있게 된다. 동시에 다형성도 구현된다.
```Java
    class Mutalisk extends ZergUnit {
    		void move(int x, int y) {
    				// 고유의 속도를 가지고 좌표로 이동
    		}
    
    		void recover(int timeFlag) {
    				// 고유의 회복속도를 가지고 HP를 회복
    		}
    
    		void attack() {
    				// 공격기능
    		}
    }
```
인터페이스는 동일 동작을 보장하는 개념이라고 했었다. 모든 ZergUnit이 오버로드라는 유닛에 탈 수 있는 것은 아니다. 일부 유닛만이 타는 기능을 할 수 있다. 이러한 상황에서 일부 유닛이 오버로드에 타는 기능을 보장하는 인터페이스 Shippable을 만들어서 객체에 구현할 수 있다.
```Java
    interface Shippable {
    }
```
해당 인터페이스를 구현한 객체들은 이제 모두 오버로드라는 유닛에 탈 수 있는 동일 기능을 보장하게 되는 것이다.
```Java
    class Overlord extends ZergUnit {
    		void move(int x, int y) {
    				// 고유의 속도를 가지고 좌표로 이동
    		}
    
    		void recover(int timeFlag) {
    				// 고유의 회복속도를 가지고 HP를 회복
    		}
    
    		void attack() {
    				// 공격기능
    		}
    		
    		void ship(Shippable s){
    			// Shippable한 유닛을 태운다.
    		}
    }
```
너무 주저리주저리 한 면이 없지 않아서 정리하면

추상클래스는 **관련성이 높은 클래스 간에 코드를 공유**하면서 동시에 **하위클래스는 확장성을 보장**하고 싶은 목적으로 사용하고, 인터페이스는 **어떤 기능을 명세**하고 싶을 때, 근데 **구현한 모든 객체에서 같은 기능을 보장**하면서. 라고 정리해볼 수 있을 것 같다.

자 이제 뜬 구름 잡는 코드는 좀 옆에 레퍼런스로 두고, 실제 안드로이드에서는 어떻게 추상클래스와 인터페이스가 활용되고 있는지 알아보자.
